# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeocubesPlugin
                                 A QGIS plugin
 Interface to download raster data from GeoCubes Finland
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2019-06-04
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Paikkatietokeskus FGI
        email                : lassi.lehto@nls.fi
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from PyQt5.QtCore import (QSettings, QTranslator, qVersion, QCoreApplication, 
                          Qt, QUrl, QEventLoop, QFileInfo)
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import (QAction, QTableWidgetItem, QSizePolicy, QFileDialog, 
                             QTableWidget, QHeaderView, QMessageBox, QInputDialog,
                             QLineEdit)
from qgis.core import (QgsProject, QgsCoordinateReferenceSystem, QgsRasterLayer,
                       Qgis, QgsVectorLayer, QgsFileDownloader, QgsExpression,
                       QgsFeatureRequest, QgsMessageLog)
from qgis.gui import (QgsBusyIndicatorDialog, QgsMessageBar)

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .geocubes_plugin_dialog import GeocubesPluginDialog
import os.path, requests, re
from .MapWindow import MapWindow
from .PolygonMapWindow import PolygonMapWindow
from .ExploreMapWindow import ExploreMapWindow


class GeocubesPlugin:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'GeocubesPlugin_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)

            if qVersion() > '4.3.3':
                QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&GeoCubes Plugin')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('GeocubesPlugin', message)


    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/geocubes_plugin/geocubes_icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'Download harmonised raster data'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&GeoCubes Plugin'),
                action)
            self.iface.removeToolBarIcon(action)

    def setResolution(self):
        """Resolution is set to be the one currently in the box"""
        self.resolution = self.resolution_box.currentText()
        
    def setFileSizeCap(self, file_size):
        self.file_size_cap = file_size
        
    def setAdminArea(self):
        self.admin_area = self.admin_areas_box.currentText()
        
    def sendWarning(self, title, text, duration, warning=True):
        """Creates an informative warning on the top of the widget"""
        if warning:
            self.msg_bar.pushMessage(title, text, Qgis.Warning,
                                     duration = duration)
        else:
            self.msg_bar.pushMessage(title, text, Qgis.Info,
                                     duration = duration)
    
    def setOptimalResolution(self):
        """
        Automatically suggests a resolution for the current map scale.
        Activated when user moves the canvas and updates the resolution box.
        Suggested resolution is reached via this formula:
        https://www.esri.com/arcgis-blog/products/product/imagery/on-map-scale-and-raster-resolution/?rmedium
        
        Scrap that. It's reached via an ad hoc formula.
        """
        ext = self.getExtents()
        
        if not ext:
            self.sendWarning("No valid input for resolution calculation", 
                             "Please select parameters first.", 6)
            return
        # get max and min values from the qgsrectangle
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        
        # difference of these values is the length of one side of the rectangle
        x_meter = xmax-xmin
        y_meter = ymax-ymin
        
        # this is arbitrary. Increase divider value to make the formula suggest
        # higher resolutions (=smaller values) easier and vise versa.
        divider = 1200
        optimal_resolution = (x_meter/divider) + (y_meter/divider)

        # fetch all resolutions from the box as integers
        all_resolutions = [int(self.resolution_box.itemText(i)) for i in range(self.resolution_box.count())]
        
        # find the resolution closest to the ones available. See:
        # https://stackoverflow.com/questions/12141150/from-list-of-integers-get-number-closest-to-a-given-value
        # in a try clause because it has sometimes errored due to unknown reasons
        try:
            closest_resolution = min(all_resolutions, key=lambda x:abs(x-optimal_resolution))
        except Exception:
            return
        
        resolution_idx = self.resolution_box.findText(str(closest_resolution))
        
        self.resolution_box.setCurrentIndex(resolution_idx)
        
        self.setResolution()
        
        self.updateInfoText()
        
    def getExtents(self):
        """Checks which crop type is selected, gets appropriate bounding box.
        Extent box should always have values, others might not. 
        Ext is empty if values are absent. Does nothing if crop method's not selected."""
        if self.bbox_radio_button.isChecked():
            ext = self.getBboxExtent()
            return ext
        elif self.admin_radio_button.isChecked():
            ext = self.bboxOfSelectedAreas()
            return ext
        elif self.poly_radio_button.isChecked():
            ext = self.poly_map_canvas.getPolygonBbox()
            return ext
        else:
            return False
            
    def getDatasets(self):
        """Sends a query to Geocubes and receives text describing the data.
           Returns a list of strings containing the datasets if query succeeds"""
        
        # request info from the server: if no response in 10 seconds, timeout
        response = requests.get(self.url_base + "/info/getDatasets", timeout=6)
        
        # request status code indicates whether successful: if not, return false
        # and warn user
        status_code = response.status_code
        
        valid_check = self.requestValidity(status_code, "datasets")
        
        if not valid_check:
            return
        else:
            # decode from bytes to string
            dataset_string = response.content.decode("utf-8")
            return dataset_string
    
    def getLabels(self, name):
        """Requests label values for a specific layer and return that csv string"""
        response = requests.get(self.url_base+"/legend/listLabels/"+name,
                                timeout=6)
        status_code = response.status_code
        
        valid_check = self.requestValidity(status_code, "labels")
        
        if not valid_check:
            return
        else:
            # decode from bytes to string
            response_string = response.content.decode("utf-8")
            
            return response_string
        
    def bboxCropSelected(self):
        """Activated when the corresponding radio button is checked. Makes
            only the selections that are currenly relevant available. For example
            you only need the extent box to be active for a bbox crop."""
        self.extent_box.setEnabled(True)
        self.admin_areas_box.setEnabled(False)
        self.areas_box.setEnabled(False)
        self.map_select_button.setEnabled(False)
        self.poly_draw_button.setEnabled(False)
        
        # updating info text with the correct crop method
        self.crop_method_text = "Cropping with a bounding box"
        self.updateInfoText()
        
    def adminAreaCropSelected(self):
        """See bboxCropSelected above"""
        self.extent_box.setEnabled(False)
        self.admin_areas_box.setEnabled(True)
        self.areas_box.setEnabled(True)
        self.map_select_button.setEnabled(True)
        self.poly_draw_button.setEnabled(False)
        self.crop_method_text = "Cropping with administrative areas"
        self.updateInfoText()
        
    def polygonCropSelected(self):
        """See bboxCropSelected above"""
        self.extent_box.setEnabled(False)
        self.admin_areas_box.setEnabled(False)
        self.areas_box.setEnabled(False)
        self.map_select_button.setEnabled(False)
        self.poly_draw_button.setEnabled(True)
        
        self.crop_method_text = "Cropping with a drawn polygon"
        self.updateInfoText()
        
    def requestValidity(self, s_code, request_type):
        """Checks if the network request errored and shows an informative msg
            to the user."""
        if (s_code == 204):
            self.sendWarning("Empty response", "Failed to fetch " + request_type
                             + ". Error: "+ str(s_code), 8)
            return False
        
        elif (s_code >= 500):
            self.sendWarning("Server error", "Failed to fetch " + request_type +
                             ". Error: "+ str(s_code), 8)
            return False
        
        elif (s_code >= 400):
            self.sendWarning("Client error", "Failed to fetch " + request_type +
                             "Code: "+str(s_code), 8)
            return False
        else:
            return True

    def setToTable(self):
        """
        Activated when user clicks "Fetch datasets" button. This function
        lists available data to the user and creates checkboxes that allow
        the selection of said data. Also creates signals that cannot be
        created on first start, like the signal emitted when clicking 
        on a checkbox.
        """
        # if previous signals exist, i.e. the plugin is started multiple times,
        # remove the connections. If none exist, pass
        try: self.table.itemChanged.disconnect() 
        except Exception: pass
    

        # get a list of datasets
        dataset_string = self.getDatasets()
        
        # if capabilities query failed, don't run code below
        if not dataset_string:
            return
        
        self.explore_data_button.setEnabled(True)
        # datasets are divided by semicolons: split at semicolons
        datasets = dataset_string.split(';')

        self.table.setColumnCount(4)
        # start with only 1 row, add more as needed
        self.table.setRowCount(1)
        # set headers for all 4 columns
        self.table.setHorizontalHeaderLabels(['Dataset', 'Year', 
                                         'Max resolution (m)', 'Select layer'])

        # loop through all the datasets
        for i, dataset in enumerate(datasets):
            # entries in the datasets are separated by commas
            dataset_split = dataset.split(',')

            # each entry has seven pieces of info, but only four are needed

            # label = a plain language name for the dataset: can have spaces etc.
            label = dataset_split[0]

            # name = version of label used in queries etc.
            name = dataset_split[1]
            years = dataset_split[2]
            # maxres = maximum resolution of the dataset in meters
            maxres = dataset_split[5]
            
            bit_depth = dataset_split[6]

            # years are separated by periods
            years_split = years.split('.')
            
            # one dataset may have data from multiple years
            # this is handled by adding each year on its own row
            for year in years_split:
                # the strings must be transformed to Qt Items
                label_entry = QTableWidgetItem(label)
                maxres_entry = QTableWidgetItem(maxres)
                year_entry = QTableWidgetItem(year)
                
                # create a checkbox for each row
                checkbox_entry = QTableWidgetItem()
                checkbox_entry.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
                # start with checkbox unchecked
                checkbox_entry.setCheckState(Qt.Unchecked)
                
                # get the current row count from the table
                row_count = self.table.rowCount()
                
                """Next, add info of the dataset to our dictionary. The dict
                will later be accessed via the list of downloadable datasets:
                it will house the keys. This way may seem redundant, but it's done
                since the name variable isn't needed on the table but is later
                necessary for the queries. Key is stored as a string and 
                value as a tuple"""
                key = label + ";" + year
                value = (name, bit_depth, maxres, year)
                
                self.datasets_all[key] = value
                
                # add the previously created items on the table
                self.table.setItem(row_count-1, 0, label_entry)
                self.table.setItem(row_count-1, 1, year_entry)
                self.table.setItem(row_count-1, 2, maxres_entry)
                self.table.setItem(row_count-1, 3, checkbox_entry)
                
                # if there're datasets left, add a new row
                if i < len(datasets)-1:
                    self.table.setRowCount(row_count+1)
        
        # fit column sizes to the items
        self.table.resizeColumnsToContents()
        
        # when an item's content are changed, or in this case, when a checkbox
        # is checked or unchecked, run the function
        self.table.itemChanged.connect(self.checkboxState)
        
        # add or subtract from the layer count
        self.table.itemChanged.connect(self.updateInfoText)
        
    def deselectDatasets(self):
        """Nullifies selections on the datasets table."""
        for row_id in range(self.table.rowCount()):
            # checkbox is on the fourth column counting from left
            cbox = self.table.item(row_id, 3)
            # 0 = not selected
            cbox.setCheckState(0)
            
        self.updateInfoText
        
    def updateInfoText(self):
        """Updates info text with current information. Called when any of these
        (resolution, crop method or layer count) changes."""
        if not self.resolution:
            res_text = "No resolution selected"
        else:
            res_text = "Resolution set to " + self.resolution + " m"
        if len(self.datasets_to_download) == 1:
            self.layer_count_text.setText(str(len(self.datasets_to_download))+
                                          ' layer selected | ' + res_text + ' | ' +
                                          self.crop_method_text)
        else:
            self.layer_count_text.setText(str(len(self.datasets_to_download))+
                                          ' layers selected | ' + res_text + ' | ' +
                                          self.crop_method_text)
        
    def checkboxState(self, cbox):
        """itemChanged signal passes the checkbox (cbox). This function
           checks whether cbox was checked or unchecked and acts accordingly"""
        state = cbox.checkState()
        
        # 0 = unchecked, 2 = checked
        if state == 0:
            self.stateNegative(cbox)
        elif state == 2:
            self.statePositive(cbox)

    def stateNegative(self, cbox):
        """This function is called in case the cbox is unchecked.
           Removes the dataset in question from the list"""
           
        # cbox has a function to access its row number in the table
        # this is used to access label and year items,
        # since they're on the same row and their column number are known
        box_row = cbox.row()
        label_item = self.table.item(box_row, 0)
        label_text = label_item.text()
        
        year_item = self.table.item(box_row, 1)
        year_text = year_item.text()
        
        # create key in the same format as before
        dataset_key = label_text + ";" + year_text
        
        # if key already exists, remove it
        if dataset_key in self.datasets_to_download:
            self.datasets_to_download.remove(dataset_key)
    
    def statePositive(self, cbox):
        """This function is called in case the cbox is checked.
           Adds the dataset in question from the list. See above for details"""
        box_row = cbox.row()
        label_item = self.table.item(box_row, 0)
        label_text = label_item.text()

        year_item = self.table.item(box_row, 1)
        year_text = year_item.text()

        dataset_key = label_text + ";" + year_text
        self.datasets_to_download.append(dataset_key)

    def deleteDownloads(self):
        """Called when datasets are fetched more than once, which empties the list.
           Also updates layer count text"""
        self.datasets_to_download.clear()
        self.updateInfoText()
    
    def estimateFileSize(self, bit_depth, name):
        """Is activated when user downloads datasets. Estimates the file size
        of a single layer download in MB based on known factors. These are:
        -extent, how many x & y lines there are and therefore, how many pixels
        -radiometric resolution (aka bit depth or data type in QGIS): 8, 16 and 32 bit
         datasets area currently available on Geocubes Finland.
         
         User is given an option to stop the download if the estimated value is
         over a set threshold."""
        
        ext = self.getExtents()
        if not ext:
            return True
        
        xmin = ext.xMinimum()
        xmax = ext.xMaximum()
        ymin = ext.yMinimum()
        ymax = ext.yMaximum()
        
        # pixelcount = (x-axis / resolution) * (y-axis/resolution)
        pixelcount = (xmax-xmin)/int(self.resolution) * ((ymax-ymin)/ int(self.resolution))
        
        # times radiometric resolution
        size_in_bits = pixelcount * int(bit_depth)
        
        # size in bits -> to bytes -> to kB -> to MB
        size_in_mb = size_in_bits/8/1024/1024
        hard_limit = 1000
        
        if size_in_mb > hard_limit:
            QMessageBox.information(self.dlg, "File size over the limit", 
                                    "The raw file size of layer " + name + 
                                    " is estimated to be " + str(int(size_in_mb)) + 
                                    " MB, which over the hard limit of " + str(hard_limit) + " MB. " +
                                    "The layer can't therefore be downloaded. Please " +
                                    "decrease resolution or crop area size and try again.")
            return False
            
        if size_in_mb > int(self.file_size_cap):
            buttonReply = QMessageBox.question(self.dlg, 'File size warning', 
                        "Raw file size of layer " + name + " is estimated to be " +
                        str(int(size_in_mb)) + " MB, which is over the suggested limit ("+
                        str(self.file_size_cap)+" MB). Download might take a long time or the layer might make" + 
                        " QGIS run slowly or crash. Do you want to proceed with the download?",
                        QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if buttonReply == QMessageBox.Yes:
                return True
            else:
                return False
        else:
            return True
        
    def getValues(self):
        """Extracts all values (name/year tuples). Returns them as a list"""
        values = []
        
        for dataset_key in self.datasets_to_download:
            # get value by passing the key from the download list
            value = self.datasets_all[dataset_key]
            values.append(value)
            
        return values
            
    def getData(self):
        """
        Downloads raster datasets from Geocubes servers as selected by the user
        This is done by forming an url comprised of layer names, years, extent
        and resolution. Directly creates a QGis raster layer by 
        passing the url as data source. Another option is to save layers
         to disk and passing path to the saved layer as the source.
        """
        # does several checks. Any one of these will stop the download operation
        # for example, the first one checks for empty download list
        if not self.datasets_to_download:
            self.sendWarning("Missing data", "Please select one or more data layers!", 8)
        elif not self.resolution:
            self.sendWarning("Missing data", "Please select resolution!", 8)
        elif self.admin_radio_button.isChecked() and not self.areas_box.checkedItems:
            self.sendWarning("Missing selection","Please select admin areas!", 8)
        elif self.poly_radio_button.isChecked() and not self.polygon_list:
            self.sendWarning("Invalid or no polygon","Please redraw polygon", 8)
        elif (not self.admin_radio_button.isChecked() and not self.bbox_radio_button.isChecked()
        and not self.poly_radio_button.isChecked()):
            self.sendWarning("Crop method missing","Please select one of the "+
                                 "three crop methods", 8)
        else:
            # get info that's passed to the Geocubes server
            dataset_parameters = self.getValues()
            
            # while datasets are downloaded, an indicator will be shown
            self.busy_dialog.show()
            
            # a simple count of successful downloads
            self.successful_layers = 0
            
            # 1 to n loops to download all selected data
            for parameter in dataset_parameters:
                
                # accessing values, which are stored as tuples
                name = parameter[0]
                bit_depth = parameter[1]
                maxres = parameter[2]
                year = parameter[3]
                
                # check if selected resolution is higher than the maximum of
                # this layer. E.g. if user tries to download km10 with 2 m resolution.
                # Set resolution for this download loop to maximum allowed 
                # (usually 10 meters)
                if int(self.resolution) < int(maxres):
                    QMessageBox.information(self.dlg, 'Selected resolution not'+
                                ' suitable for layer ' +name, 'Selected resolution (' 
                                + self.resolution +' m) is higher than the maximum'
                                +' available resolution for this layer (' +
                                maxres + ' m). Download resolution set to '+ maxres +
                                ' m for this layer.')
                    self.resolution = maxres
                
                # if a tif image is downloaded, estimate its file size
                # should the user choose to stop the download or the size is over the hard limit 
                # return to the beginning of the loop
                if self.gtiff_radio_button.isChecked():
                    proceed = self.estimateFileSize(bit_depth, name)
                    if not proceed:
                        self.sendWarning("Download stopped", "Download of " +
                                         name + " layer was stopped due to download size.",
                                         8, warning=False)
                        continue
                    
                # forming the url that's passed to server. 
                # see: http://86.50.168.160/geocubes/examples/ for examples.
                # Url uses either bbox, polygon or admin areas based on user choice
                if self.bbox_radio_button.isChecked():
                    data_url = self.formBboxUrl(name, year)
                elif self.poly_radio_button.isChecked():
                    data_url = self.formPolygonUrl(name, year)
                else:
                    data_url = self.formAdminUrl(name, year)
                
                # log message containing the url. For advanced users
                QgsMessageLog.logMessage('Download url for layer ' + name + ': ' + data_url,
                                         'Geocubes plugin',
                                         Qgis.Info)
                
                # activate saving to disk procedure with the appropriate file
                # format, given the button is selected. If not, add straight to QGIS
                if self.save_disk_button.isChecked():
                    if self.gtiff_radio_button.isChecked():
                        file_format = 'tif'
                    else:
                        file_format = 'vrt'
                    self.saveData(data_url, file_format, name)
                    
                else:
                    self.addLayerToQgis(data_url, name=name, year=year, label=name)
                
                self.setResolution()
                    
            # once all layers are downloaded, inform how many were succesful
            data_text = (str(self.successful_layers) + "/" +
                                str(len(dataset_parameters))+ " layer(s)" +
                                " downloaded")
            self.sendWarning("Download complete", data_text, 9, warning=False)

            self.busy_dialog.close()
            
            if self.deselect_on_download_cb.isChecked():
                self.deselectDatasets()
            self.updateInfoText()
            
    def addLayerToQgis(self, url, name="", year="", label="geocubes_raster_layer"):
        """This function receives an url address to access the files at the
            Geocubes servers. It creates a raster layer based on that url, 
            gives it a label and add the layer to QGIS. If the data is
            categorized (say, Corine), then those categories are labeled."""
            
        # creating raster layer by passing the url and giving
        # name and year as layer names
        layer_name = label + '_' + year
        if self.vrt_radio_button.isChecked() and name == label:
            layer_name = layer_name + '_vrt'
            
        if self.layer_name_config_cb.isChecked() and self.save_temp_button.isChecked():
            input_name, ok_pressed = QInputDialog.getText(self.dlg, "Give layer a title for QGIS",
                                                      "Write name of layer "+ label + " ("+year+ ")",
                                                      QLineEdit.Normal, "")
            if ok_pressed and input_name != "":
                layer_name = input_name
        
        raster_layer = QgsRasterLayer(url, layer_name)
                    
        # if data query fails, inform user. If not, add to Qgis
        if not raster_layer.isValid():
            self.sendWarning("Layer invalid", ''.join([name,'_',year])+
                                     " failed to download", 9)
        else:
            """If raster layer renderer is of type QgsPalettedRasterRenderer,
            it's most likely categorized data that has labels.
            These labels are first queried, then formatted and
            lastly inserted to the layer. Otherwise the step is skipped"""

            if raster_layer.renderer().type() == 'paletted':
                label_string = self.getLabels(name)
                if label_string:
                    label_list = self.formatLabels(label_string)
                    self.insertLabels(label_list, raster_layer.renderer())
                    
            # insert raster layer to main canvas and Qgis legend for use
            QgsProject.instance().addMapLayer(raster_layer)
            self.successful_layers += 1
            
    def bboxOfSelectedAreas(self):
        """Queries the areas selected by the user from the admin area 
            vector layer. Selection must be made with feature id's, hence a rather
            contrived method to get them. Derives a bounding box (qgsrectangle) of the selection.
            Returns either that or a boolean false in case no items are selected."""
        
        # column name to query from
        # blocks layer has different column names compared to the to others
        if self.admin_area == "Blocks":
            column_name = "uleast"
        else:
            column_name = "namefin"
        
        ids = []
        
        # get checked items as a list of strings
        items = self.areas_box.checkedItems()
        
        # if no items are checked, return false
        if len(items) == 0:
            return False
        
        # loop through the selections
        for item in items:
            # use only the name, e.g.Tampere or code in case of blocks
            split = item.split('|')
            name = split[0]
            
            # building the expression. Follows sql standards, I think?
            expression = QgsExpression("\"{}\"='{}'".format(column_name, name))
            # get features with the expression – should return just one
            iterator = self.vlayer.getFeatures(QgsFeatureRequest(expression))
            
            # get id codes of the feature
            index = [i.id() for i in iterator]
            
            ids.append(index[0])
        
        # finally, make selection based on the id list
        self.vlayer.selectByIds(ids)
        
        bbox = self.vlayer.boundingBoxOfSelected()
        
        # remove selection, otherwise it causes harm on the map window
        self.vlayer.removeSelection()
        
        return bbox

    def downloadFailed(self, error):
        """Run in case the file downloader errors"""
        self.loop.exit()
        self.sendWarning("Download failed", "Error: " + str(error), 10)
        
    def downloadSucceeded(self, file_path, file_name, layer_name):
        """If the downloader succeeds, the file has now been downloaded on disk
            User has the option to add this layer to QGIS. It will be added to 
            QGIS as a layer via the file path given by user"""
        self.loop.exit()
        
        if self.add_layer_without_asking_cb.isChecked():
            self.addLayerToQgis(file_path, label=file_name, name=layer_name)
        else:
            buttonReply = QMessageBox.question(self.dlg, 'Add layer to QGIS', 
                        "Download successful. Do you want to add layer "+ file_name +
                        " to QGIS?",
                        QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
            if buttonReply == QMessageBox.Yes:
                self.addLayerToQgis(file_path, label=file_name, name=layer_name)
            else:
                self.successful_layers += 1
            
    def saveData(self, url, file_format, name):
        """This function first asks the user for a file name, then downloads
            the raster file from the server using the url from getData and
            saves it as the defined file name."""
        self.loop = QEventLoop()
        file_path, file_filter = QFileDialog.getSaveFileName(self.dlg,
                                "Save " + name, filter='Selected format: (*.'+file_format+')')
        if not file_path:
            self.sendWarning("Filepath required", "Please write a valid filename", 10)
            return
        
        file_path_qt = QFileInfo(file_path)
        file_name = file_path_qt.fileName()
        
        # downloader requires url as QUrl
        qt_url = QUrl(url)
        
        # this handles the download and then destructs
        downloader = QgsFileDownloader(qt_url, file_path)
        
        # signals for both fail and success
        downloader.downloadError.connect(self.downloadFailed)
        downloader.downloadCompleted.connect(lambda: self.downloadSucceeded(file_path, file_name, name))
        
        downloader.startDownload()
        
        self.loop.exec_()
    
    def formatLabels(self, label_string):
        """Server returns a string with items separated by commas. This function
            formats that data so that the output is a list of tuples. The tuples
            consist of an index number (which value the label refers to) and
            the label itself.
            """
        label_list = label_string.split(';')
        formatted_labels = []
        
        for label in label_list:
            # example label looks like this: Uusimaa(1)
            # splitting at bracket allows us to handle both name and idx
            split_label = label.split("(")
            name = split_label[0]
            number_string = split_label[len(split_label)-1]
            
            # a regex query is made to catch 1 to n numbers
            regex_nmr = re.search("[0-9]+", number_string)
            
            # if the query fails, do nothing. Else, add to list
            if regex_nmr is None:
                pass
            else:
                nmr = regex_nmr.group()
                formatted_label = (nmr, name)
                formatted_labels.append(formatted_label)
                
        return formatted_labels
    
    def insertLabels(self, labels, renderer):
        """Renderer houses classification of the data. Method combines the labels
            with the correct raster values (index values)"""
        for label in labels:
            index = int(label[0])
            name = label[1]

            renderer.setLabel(index, name)
                            
    def formBboxUrl(self, name, year):
        """Forms the url for a bbox clip"""
        extent = self.getBboxExtent()
        bbox_url = (self.url_base + "/clip/" + self.resolution +
                        "/"+ name +"/bbox:" + self.formatExtent(extent)
                        + "/" + year)
        
        if self.vrt_radio_button.isChecked():
            bbox_url = bbox_url+"/vrt/mr"
        return bbox_url
    
    def formAdminUrl(self, name, year):
        """Forms the url for an admin area clip"""
        areas = self.areas_box.checkedItems()
        admin_url = (self.url_base + "/clip/" + self.resolution +"/"+ name +
                     "/"+self.admin_area.lower()+":" + self.formatAreas(areas)
                        + "/" + year)
        if self.vrt_radio_button.isChecked():
            admin_url = admin_url+"/vrt/mr"
        return admin_url
    
    def formPolygonUrl(self, name, year):
        """Forms the url for an user drawn polygon clip"""
        poly_url = (self.url_base + "/clip/" + self.resolution +
                    "/"+ name +"/polygon:" + self.formatPolygon()
                    + "/" + year)
        if self.vrt_radio_button.isChecked():
            poly_url = poly_url+"/vrt/mr"

        return poly_url
            
    def getAreas(self):
        """Fetches a vector data of administrative divisions from Geocubes WFS 
           server. Passes this on to another function."""

        # don't do anything if the box is empty
        if not self.admin_area:
            return
        
        # create a string to fetch the correct data
        area_name = "ogiir:" + self.admin_area.lower()
        if self.admin_area != "Blocks":
            area_name = area_name + "_4500k"
        
        self.busy_dialog.show()
        url = ("https://vm0160.kaj.pouta.csc.fi/geoserver/ows?service=wfs&version=2.0.0"+ 
        "&request=GetFeature&typename="+area_name+"&pagingEnabled=true")
        
        # pass url, label and data provider
        vector_layer = QgsVectorLayer(url, "WFS-layer-TO-BE-REMOVED", "WFS")
        
        if not vector_layer.isValid():
            self.sendWarning("Query error", "WFS query failed", 8)
            self.busy_dialog.close()
        else:
            # if everything went well, run another function on the layer
            if self.admin_area == "Blocks":
                self.updateAreaBox(vector_layer, block_flag = True)
            else:
                self.updateAreaBox(vector_layer)
            self.vlayer = vector_layer

    def openMapWindow(self):
        """Check if user has selected an admin layer. If yes, pass a copy of 
            that layer to the window and open it"""
        if not self.map_canvas:
            self.map_canvas = MapWindow()
            self.map_canvas.finished.connect(self.mapSelectionToBox)
        if (not self.vlayer or not self.admin_areas_box.currentText()):
            self.sendWarning("Layer missing", "Select admin division first", 6)
        else:
            # vector layer itself can't be passed to the mapwindow, since
            # it's removed from project after use – removal deletes the layer.
            # Therefore, an exact copy is created
            scrap_vlayer = self.vlayer.clone()
            if self.admin_area == "Blocks":
                self.map_canvas.addBlocksLayer(scrap_vlayer)
            else:
                self.map_canvas.addLayer(scrap_vlayer)

    def openPolyMapWindow(self):
        if not self.poly_map_canvas:
            self.poly_map_canvas = PolygonMapWindow()
            self.poly_map_canvas.finished.connect(self.getMapPolygon)
        
        self.poly_map_canvas.showCanvas()
        
    def openExploreMapWindow(self):
        if not self.explore_map_canvas:
            self.explore_map_canvas = ExploreMapWindow(self.url_base)

        self.explore_map_canvas.showCanvas(self.datasets_all)
        
    def getMapPolygon(self):
        """Activated when signal indicating polygon drawing is finished is emitted.
            Gets the list of point values and does a simple but hopefully exhaustive
            check of the polygon validity. Warn the user if the polygon is faulty.
            If valid, indicate by checking the appropriate box."""
        
        self.polygon_list = self.poly_map_canvas.getPolygon()
        
        # assumes that the polygon must have at least 3 points. First and last
        # points must also be the same (this error shoudln't happen but who knows)
        if (len(self.polygon_list)<3 or not self.polygon_list[0] ==
        self.polygon_list[len(self.polygon_list)-1]):
            self.sendWarning("Invalid polygon", "Please redraw polygon", 8)
            self.polygon_list.clear()
            self.poly_checkbox.setChecked(False)
        else:
            self.poly_checkbox.setChecked(True)
            
    def mapSelectionToBox(self):
        """Activated when map canvas emits 'finished' signal. Gets a list of
            items selected by the user and checks these on the areas box"""
        self.areas_box.deselectAllOptions()
        map_selection = self.map_canvas.getSelection()
        self.areas_box.setCheckedItems(map_selection)
            
    def updateAreaBox(self, vlayer, block_flag = False):
        """Populates the selectable box with whatever administrative areas
            the user has picked."""
        self.areas_box.clear()
        name_list = []
        block_minus = 0
        
        # blocks' attribute tables are different than the rest
        # the features wanted are on a different column, hence the need to
        # subtract from the column count
        if block_flag:
            block_minus = 1
        
        # loop through features or rows in the layer
        for feature in vlayer.getFeatures():
            name_fi = feature[2-block_minus]
            id_code = feature[1-block_minus]
            # create a string from Finnish name and id code
            if block_flag:
                key = str(id_code) + "|" + str(name_fi)
            else:
                key = name_fi + "|" + str(id_code)
            
            name_list.append(key)
                
        name_list.sort()
        # add all area strings to the box
        self.areas_box.addItems(name for name in name_list)
        self.busy_dialog.close()
    
    def updateExtent(self):
        """Updates extent boxes when the canvas extent changes"""
        self.extent_box.setCurrentExtent(self.canvas.extent(), self.proj_crs)
        self.extent_box.setOutputExtentFromCurrent()
            
    def getBboxExtent(self):
        """Current extent shown in the extent groupbox
        Returns a rectangle object"""
        output_extent = self.extent_box.outputExtent()
        return output_extent
        
    def questionCrs(self):
        """Called if QGIS' CRS isn't EPSG:3067. Asks the user to change destination
            CRS and changes if allowed. If refused, warns the user."""
            
        buttonReply = QMessageBox.question(self.dlg, 'Incorrect CRS set', 
                        "To function correctly, some features of this plugin "+
                        "require that Coordinate Reference System is set to EPSG:3067."+
                        " Do you want to change the current project CRS to EPSG:3067?",
                        QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if buttonReply == QMessageBox.Yes:
            QgsProject.instance().setCrs(self.proj_crs)
        else:
            self.sendWarning("Incorrect CRS set", "Some features may not work"+
                             " or they function incorrectly", 7)
            
    def updateSettings(self):
        """Activated when settings are saved. Stores the new settings in the
        ini-file."""
        if not self.plugin_settings:
            return
        
        if self.layer_name_config_cb.isChecked():
            self.plugin_settings.setValue("ask_layer_name", 1)
        else:
            self.plugin_settings.setValue("ask_layer_name", 0)
            
        if self.deselect_on_download_cb.isChecked():
            self.plugin_settings.setValue("deselect_on_download", 1)
        else:
            self.plugin_settings.setValue("deselect_on_download", 0)
            
        if self.deselect_on_download_cb.isChecked():
            self.plugin_settings.setValue("add_to_qgis_prompt", 1)
        else:
            self.plugin_settings.setValue("add_to_qgis_prompt", 0)
        
        self.plugin_settings.setValue("file_size_cap", self.file_size_cap)
        
    def setDefaultSettings(self):
        """Activated when user clicks on default settings. Changes values
            on the ini file as well as the boxes."""
        if not self.plugin_settings:
            return
        
        self.plugin_settings.setValue("ask_layer_name", 0)
        self.plugin_settings.setValue("file_size_cap", 100)
        self.plugin_settings.setValue("add_to_qgis_prompt", 0)
        self.plugin_settings.setValue("deselect_on_download", 1)
        
        self.max_file_size_spin_box.setValue(100)
        self.layer_name_config_cb.setChecked(False)
        self.add_layer_without_asking_cb.setChecked(False)
        self.deselect_on_download_cb.setChecked(True)
        
        
    def formatPolygon(self):
        """Returns polygons in a url form suitable for the Geocubes API.
        Takes a list of PointXY's (tuples consisting of coordinate doubles) and
        trims them at the decimal point. Returns as a string with each value
        separated by comma."""
        polygon_str = ""
        for point in self.polygon_list:
            if not polygon_str:
                point_str = str(int(point.x()))+","+str(int(point.y()))
                polygon_str = point_str
            else:
                point_str =","+str(int(point.x()))+","+str(int(point.y()))
                polygon_str = polygon_str + point_str
        
        return polygon_str
        
    def formatExtent(self,rectangle):
        """The extent coordinates need to be in certain format for the url
            This function's input is a Qgis rectangle and output a bbox string"""
        formatted_extent = (str(rectangle.xMinimum())+','+str(rectangle.yMinimum())
                            +','+str(rectangle.xMaximum())+','+str(rectangle.yMaximum()))
        return formatted_extent
    
    def formatAreas(self, areas):
        """Return areas selected by user in a format suitable for the url. Id codes
            are used to identify features. Nationwide (valtakunta) is a special case, since
            it's handled differently to the other datasets serverside. Blocks
            are also handled in a slightly different manner"""
            
        if self.admin_area == 'Valtakunta':
            return str(1)
        if self.admin_area == "Blocks":
            codes = ""
            for area in areas:
                area_split = area.split("|")
                code = area_split[0] + "," + area_split[1]
                if not codes:
                    codes = code
                else:
                    codes = codes + "," + code
            return codes
        else:
            # empty string forms a basis for the formatting
            codes = ""
            # loop through 1 to n areas. For each, add id code to string
            for area in areas:
                area_split = area.split("|")
                code = area_split[len(area_split)-1]
                if not codes:
                    codes = code
                else:
                    codes = codes + "," + code
            return codes
        
    def run(self):
        """Run method that initializes the plugin and its variables"""

        # if the plugin is started for the first time,
        # create necessary variables and connect signals to slots
        # signal/slot connection must only be made once;
        # unless disconnected elsewhere
        if self.first_start is True:
            self.first_start = False
            # the ui
            self.dlg = GeocubesPluginDialog()
            
            # table to house the datasets: also add policies to fit the data
            # better on the table
            self.table = self.dlg.tableWidget
            """
            self.table.setSizeAdjustPolicy(
                    QAbstractScrollArea.AdjustToContents)
            """
            self.table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
            self.table.horizontalHeader().setStretchLastSection(True) 
            
            #ensures entries in the table cannot be edited
            self.table.setEditTriggers(QTableWidget.NoEditTriggers)
            
            # connect click of the fetch data layers button to functions
            self.dlg.getContents.clicked.connect(self.setToTable)
            self.dlg.getContents.clicked.connect(self.deleteDownloads)
            
            # QGIS canvas
            self.canvas = self.iface.mapCanvas()
            self.canvas.extentsChanged.connect(self.updateExtent)

            # initialising the extent box
            # all the data is in ETRS89 / TM35FIN (EPSG:3067), 
            # therefore that's the default crs
            self.extent_box = self.dlg.mExtentGroupBox
            self.proj_crs = QgsCoordinateReferenceSystem('EPSG:3067')
            
            # current base url (shared by all queries) of the Geocubes project. Modify if url changes
            self.url_base = "https://vm0160.kaj.pouta.csc.fi/geocubes"

            
            # box housing a drop-down list of possible raster resolutions
            self.resolution_box = self.dlg.resolutionBox
            self.resolution_box.activated.connect(self.setResolution)
            
            self.resolution_box.activated.connect(self.updateInfoText)
            
            # map windows are initialized in the proper functions when/if first needed 
            self.map_canvas = False
            self.poly_map_canvas = False
            self.explore_map_canvas = False
            
            self.map_select_button = self.dlg.mapSelectButton
            self.map_select_button.clicked.connect(self.openMapWindow)
            
            self.poly_draw_button = self.dlg.polyDrawButton
            self.poly_draw_button.clicked.connect(self.openPolyMapWindow)
            
            self.explore_data_button = self.dlg.exploreDataButton
            self.explore_data_button.clicked.connect(self.openExploreMapWindow)
            
            self.data_button = self.dlg.getDataButton
            self.data_button.clicked.connect(self.getData)
            
            self.optimal_res_button = self.dlg.optimalResolutionButton
            self.optimal_res_button.clicked.connect(self.setOptimalResolution)
            
            # text that tells the user the current count of selected layers and other info
            self.layer_count_text = self.dlg.layerCountText
            
            # radio buttons for user to decide whether to get the data as
            # temporary layers or save the rasters to disc
            self.save_temp_button = self.dlg.saveToTempButton
            self.save_disk_button = self.dlg.saveToDiskButton
            
            # radio buttons to decide what to use when cropping the data
            self.bbox_radio_button = self.dlg.bboxRadioButton
            self.admin_radio_button = self.dlg.adminRadioButton
            self.poly_radio_button = self.dlg.polyRadioButton
            
            self.bbox_radio_button.toggled.connect(self.bboxCropSelected)
            self.admin_radio_button.toggled.connect(self.adminAreaCropSelected)
            self.poly_radio_button.toggled.connect(self.polygonCropSelected)
            
            # will house the points that form the custom polygon
            self.polygon_list = []
            
            self.crop_method_text = "No crop method selected"
            
            self.gtiff_radio_button = self.dlg.gtiffRadioButton
            self.vrt_radio_button = self.dlg.vrtRadioButton
            
            
            self.admin_areas_box = self.dlg.adminAreasBox
            self.areas_box = self.dlg.areasBox
            # below are the possible admin area divisions. Adjust if these
            # change. Use the same names as the WFS server
            admin_area_labels = ['Valtakunta', 'Aluehallintovirastojako', 
                                 'Maakuntajako', 'Kuntajako', 'Blocks']
            self.admin_areas_box.addItems(label for label in admin_area_labels)
            self.admin_areas_box.currentTextChanged.connect(self.setAdminArea)
            self.admin_areas_box.currentTextChanged.connect(self.getAreas)
            
            self.checkedAreas = []
            
            self.busy_dialog = QgsBusyIndicatorDialog("Processing... Please wait", self.dlg)
            
            # initiate message bar that warns user when something goes wrong
            self.msg_bar = QgsMessageBar(self.dlg.tabWidget)
            self.msg_bar.setMinimumSize(575, 80)
            self.msg_bar.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
            
            # false to indicate no vector layer is selected: will change, if
            # user selects an admin area
            self.vlayer = False
            
            # file size limit in MB's. If downloads are over this value a warning
            # with the option to stop the download is sent
            self.file_size_cap = 100
            self.max_file_size_spin_box = self.dlg.maxFileSizeSpinBox
            self.max_file_size_spin_box.valueChanged.connect(self.setFileSizeCap)
            
            # an empty dictionary to house all the fetched datasets
            self.datasets_all = {}
        
            # an empty list for only the datasets the user has selected
            self.datasets_to_download = []
            
            self.poly_checkbox = self.dlg.polyCheckbox
            
            # configuration checkboxes and buttons
            self.layer_name_config_cb = self.dlg.layerNamingConfigCheckBox
            self.add_layer_without_asking_cb = self.dlg.addLayerWithoutAskingCheckBox
            self.deselect_on_download_cb = self.dlg.deselectAfterDownloadCheckBox
            
            self.config_save_button = self.dlg.configSaveButton
            self.config_save_button.clicked.connect(self.updateSettings)
            
            self.default_setting_button = self.dlg.defaultSettingButton
            self.default_setting_button.clicked.connect(self.setDefaultSettings)
            
            # list of possible resolutions. Update if this changes
            resolutions = [1, 2, 5, 10, 20, 50, 100, 200, 500, 1000]
            self.resolution_box.addItems(str(resolution) for resolution in resolutions)
            
        """Code below is ran every time the plugin is restarted but Qgis isn't"""
        
        # set the box empty by default
        self.resolution_box.setCurrentIndex(-1)
        
        # this variable houses the currently selected resolution
        self.resolution = self.resolution_box.currentText()
        
        self.admin_areas_box.setCurrentIndex(-1)
        self.admin_area = self.admin_areas_box.currentText()
        
        # set default text
        self.updateInfoText()
        
        # setting default radio button selections
        self.save_temp_button.setChecked(True)
        self.gtiff_radio_button.setChecked(True)
        self.bbox_radio_button.setChecked(True)
        
        # empty areas and dataset selections
        self.areas_box.clear()
        self.deselectDatasets()
        
        # canvas extent at the start
        og_extent = self.canvas.extent()
        
        # these three things must be set when initialising the extent box
        #self.extent_box.setOriginalExtent(og_extent, self.canvas.mapSettings().destinationCrs())
        self.extent_box.setCurrentExtent(og_extent, self.proj_crs)
        self.extent_box.setOutputCrs(self.proj_crs)
        
        # push current extent to the box
        self.updateExtent()
        
        # always start with the first tab ("Layer selection")
        self.dlg.tabWidget.setCurrentIndex(0)
        
        # settings initialized below. First a connection to the settings (located 
        # in the directory where this file run from) is established
        # an ini file should exist at the location
        try:
            path_to_settings = self.plugin_dir + "/geocubes_plugin_settings.ini"
            self.plugin_settings = QSettings(path_to_settings,
                               QSettings.IniFormat)
        except Exception:
            self.plugin_settings = False
        
        # if all works, create the settings
        if self.plugin_settings:
            # get number (stored as a string) from the file. If value not found,
            # use 100 by default
            self.file_size_cap = self.plugin_settings.value("file_size_cap", 100)
            # settings can't handle booleans. therefore, these are stored as
            # 0 = unchecked & 1 = checked
            ask_name_setting = self.plugin_settings.value("ask_layer_name", 0)
            add_to_qgis_setting = self.plugin_settings.value("add_to_qgis_prompt", 0)
            deselect_on_download_setting = self.plugin_settings.value("deselect_on_download", 1)
            
            # string mapped to int and then to boolean (since 0 = False)
            ask_name_setting = bool(int(ask_name_setting))
            add_to_qgis_setting = bool(int(add_to_qgis_setting))
            deselect_on_download_setting = bool(int(deselect_on_download_setting))
            
            # set the values to boxes
            self.max_file_size_spin_box.setValue(int(self.file_size_cap))
            self.layer_name_config_cb.setChecked(ask_name_setting)
            self.add_layer_without_asking_cb.setChecked(add_to_qgis_setting)
            self.deselect_on_download_cb.setChecked(deselect_on_download_setting)

        # show the dialog
        self.dlg.show()
        
        # if QGIS' CRS is not EPSG:3067, ask user if they want to change it
        if QgsProject.instance().crs() != self.proj_crs:
            self.questionCrs()
